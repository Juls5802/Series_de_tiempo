```{r}
#| warning: false
#| echo: false
library(TSstudio)
library(readxl)
library(dplyr)
library(lubridate)
library(astsa)
library(feasts)
library(fable)
library(timetk)
library(tsibble)
library(zoo)
library(xts)
library(readxl)
library(tidyverse)
library(nonlinearTseries)
library(tseriesChaos) 
library(forecast)
library(plotly)
```

```{r}
#| warning: false
#| echo: false
#| results: false
# Carga de la base de datos
AEP_hourly<-read.csv("AEP_hourly.csv")
AEP_hourly$Datetime<-as.POSIXct(AEP_hourly$Datetime, format = "%Y-%m-%d %H:%M:%S")
AEP_hourly$fecha<-as.Date(AEP_hourly$Datetime)

energia <- AEP_hourly %>%
  group_by(fecha) %>%
  summarise(Energia = sum(AEP_MW))
energia<-energia[-5055,]
energia2<-ts(energia$Energia,start=c(2004,10,01),frequency=365.25)
```

# Análisis del consumo de energía de la empresa PJM

Según lo observado en la serie de tiempo, visualmente se tiene:

-   **Heterocedasticidad marginal:** Se puede observar que la varianza de cada instante en la serie es casi la misma, por lo tanto aparentemente no es necesario estabilizar la varianza.
-   **Tendencia:** A simple vista se observa que, a medida que pasa el tiempo, la serie oscila al rededor del mismo valor, por lo tanto, aparentemente, no es necesario estimar la tendencia.
-   **Componente estacional:** Se observan algunos patrones que se repiten con cierta periodicidad, lo cual hace que sea necesario estimar posibles comportamientos estacionales.

## Estabilización de la varianza marginal

Como se observa en la gráfica de la serie de tiempo no es necesario realizar una estabilización de la varianza para continuar con el análisis descriptivo, sin embargo, se hace una transformación de Box-cox para ver que tanto se estabiliza la varianza. En la @fig-boxcox1energia se observa que se sugiere una transformación, dado que 1 no está contenido en el intervalo.

```{r}
#| label: fig-boxcox1energia
#| fig-cap: >
#|    Gráfico de la verosimilitud en función del hiperparámetro lambda.
MASS::boxcox(lm(energia2 ~ 1),seq(-5, 5, length = 50))
abline(v = 1, col = "red", lty = 2)
```

En la siguiente salida se puede ver que el $\lambda$ sugerido es $-0.25$, como es un número negativo, se procede a hacer la transformación Box-Cox usando logaritmo natural.

```{r}
forecast::BoxCox.lambda(energia2, method ="loglik",lower = -1, upper = 3)
```

En la @fig-boxcox1lenergia a continuación se muestra que la serie en escala logarítmica nuevamente no tiene la varianza estabilizada, dado que no se contiene al 1.

```{r}
#| label: fig-boxcox1lenergia
#| fig-cap: >
#|    Gráfico de la verosimilitud para la serie en escala logarítmica, en función del hiperparámetro lambda.
lenergia2=log(energia2)
MASS::boxcox(lm(lenergia2 ~ 1),seq(-5, 5, length =  50))
abline(v = 1, col = "red", lty = 2)
```

Además, gráficamente se ve, en la @fig-sinconboxcox , que no hay una diferencia significativa entre la serie transformada y no transformada. Por lo que el análisis descriptivo se continua usando los datos originales.

```{r}
#| label: fig-sinconboxcox
#| fig-cap: >
#|    Serie original y serie con transformación logarítmica.
par(mar = c(1,1,1,1))
par(mfrow=c(2,1),mar=c(3,3,3,3))
plot(energia2,main="Serie energía sin Transformar",cex.main=1)
plot(lenergia2,main="Serie energía con Transformación BoxCox",cex.main=1)
```

## Estimación preliminar de la tendencia

Como se observa en la gráfica de la serie de tiempo no es necesario realizar una estimación de la tendencia para continuar con el análisis descriptivo, sin embargo, se hace una estimación preliminar usando varios métodos.

#### Tendencia lineal

```{r}
# Creación del objeto tibble
energia_1=energia %>% map_df(rev)
Fechas=as.Date(energia_1$fecha)
energia_xts=xts(x = energia_1$Energia,frequency = 365.25,order.by = Fechas)

# Creación objeto tssible a partir del objeto tibble
df_energia=data.frame(Energia=energia_1$Energia,fecha=energia_1$fecha)
tbl_energia=tibble(df_energia)
tbl_energia_format_fecha=tbl_energia
tsbl_energia=as_tsibble(tbl_energia_format_fecha,index=fecha)
```

En la siguiente salida se presenta el ajuste de una regresión lineal para estimar la tendencia, como el $R^2$ es $0.058$, sugiere que no hay tendencia.

```{r}
# Análisis de tendencia con regresion simple
summary(fit_e<-lm(energia2~time(energia2),na.action=NULL))
```

En la @fig-serietiempoenergiareglineal se presenta la serie de tiempo de la energía con la estimación lineal de la tendencia.

```{r}
#| label: fig-serietiempoenergiareglineal
#| fig-cap: >
#|    Gráfico de la serie de tiempo de la energía con la estimación lineal de la tendencia.

plot(energia2, main="Serie de tiempo de la energía diaria de una empresa estadounidense",
     cex.main=1,
     xlab="Tiempo ",
     ylab="Energía consumida",
     cex.lab=0.4)
abline(fit_e,col="darkcyan",lwd=2)
```

```{r}
# Eliminación de la tendencia con la predicción la recta
ElimiTendenerg<-energia2-predict(fit_e)
plot(ElimiTendenerg,main="Serie energia sin tendencia",
     cex.main=1.3,
     xlab="Tiempo",
     ylab="Consumo de energia total",
     cex.lab=0.4)
```

#### Tendencia con promedios móviles

Se puede notar que está ficti.

```{r}
# Descomposición filtro de promedios móviles
energia_decompo=decompose(energia2)
plot(energia_decompo)
```

#### Tendencia con diferenciación

```{r}
tsibble_energia<-as_tsibble(energia2)
par(mar = c(2,2,2,2))
par(mfrow=c(2,1))
plot(resid(fit_e), type="l", main="Sin tendencia") #Sin tendencia quitandola con regresión
plot(diff(energia2), type="l", main="Primera Diferencia") #Primera diferencia ordinaria
```

#### Comparación de los ACF

```{r}
# Gráficos de los ACF
par(mar = c(3,2,3,2))
par(mfrow=c(3,1))
acf(energia2, 60, main="ACF energia")
acf(resid(fit_e), 60, main="ACF Sin tendencia") 
acf(diff(energia2), 60, main="ACF Primera Diferencia")
```

## Estimación de la estacionalidad

#### Detección de estacionalidad

```{r}
# Gráfica de retardos
par(mar = c(3, 2, 3, 2))
astsa::lag1.plot(energia2, 7,corr=F)
astsa::lag1.plot(diff(energia2), 7,corr=F)
```

```{r}
# Indice AMI 
tseriesChaos::mutual(energia2, partitions = 50, lag.max = 10, plot=TRUE) 
```

```{r}
#energia_df<-energia
#energia_df$time = as.POSIXct(energia_df$fecha, "%Y-%m-%d")
#energia_df$weekday <- wday(energia_df$time, label = TRUE, abbr = TRUE)
#energia_df$month <- factor(month.abb[month(energia_df$time)], levels =   month.abb)
energiasss<-rbind(energia,c("2018-08-03",0))
energia_df1<-energiasss
energia_df1$time = as.POSIXct(energia_df1$fecha, "%Y-%m-%d")
energia_df<-cbind(energia_df1[1:5054,1:2],energia_df1[2:5055,3])

energia_df$weekday <- wday(energia_df$time, label = TRUE, abbr = TRUE)
energia_df$month <- factor(month.abb[month(energia_df$time)], levels =   month.abb)

head(energia_df)
tail(energia_df)
```

```{r}
#energia_df%>%plot_seasonal_diagnostics(.date_var = time,.value = Energia,.feature_set = c("wday.lbl"),.geom="boxplot")
#energia_df%>%plot_seasonal_diagnostics(.date_var = time,.value = Energia,.feature_set = c("month.lbl"),.geom="boxplot")

# Gráfica de subseries semanal con datos originales
gg_subseries(tsbl_energia,y=Energia,period=7)
```

```{r}
# Gráfica de subseries anual con datos originales
gg_subseries(tsbl_energia,y=Energia,period=12)
```

```{r}
# Periodograma Datos originales
spectrum(as.numeric(energia2),log='no')

PeriodogramaEnergia2=spectrum(as.numeric(energia2),log='no')
ubicacionenergia=which.max(PeriodogramaEnergia2$spec)

sprintf("El valor de la frecuencia donde se maximiza el periodograma para la serie es: %s",PeriodogramaEnergia2$freq[ubicacionenergia])

sprintf("El periodo correspondiente es aproximadamente: %s",1/PeriodogramaEnergia2$freq[ubicacionenergia])
```

```{r}
# Periodograma sin tendencia lineal
spectrum(as.numeric(ElimiTendenerg),log='no')

PeriodogramaEnergia2_lineal=spectrum(as.numeric(ElimiTendenerg),log='no')
ubicacionlogenergia=which.max(PeriodogramaEnergia2_lineal$spec)

sprintf("El valor de la frecuencia donde se maximiza el periodograma para la serie es: %s",PeriodogramaEnergia2_lineal$freq[ubicacionlogenergia])

sprintf("El periodo correspondiente es aproximadamente: %s",1/PeriodogramaEnergia2_lineal$freq[ubicacionlogenergia])
```

```{r}
# Periodograma diferenciación
spectrum(as.numeric(diff(energia2)),log='no')

PeriodogramaEnergia2_dif=spectrum(as.numeric(diff(energia2)),log='no')
ubicacionlogenergia=which.max(PeriodogramaEnergia2_dif$spec)

sprintf("El valor de la frecuencia donde se maximiza el periodograma para la serie es: %s",PeriodogramaEnergia2_dif$freq[ubicacionlogenergia])

sprintf("El periodo correspondiente es aproximadamente: %s",1/PeriodogramaEnergia2_dif$freq[ubicacionlogenergia])
```

#### Desestacionalización

```{r}
s=1/PeriodogramaEnergia2$freq[ubicacionenergia]

sin_est=diff(energia2,lag=round(s),differences=1)

plot.ts(sin_est, main="Serie sin estacionalidad", ylab='')
```

Preguntar: Cuando lo hacemos con lenergia se veia que no habia tendencia, pero ahorita con los datos originales no, por la escala parece haber tendencia, y mirando el ACF se nota mucho la estacionalidad estimandola con diferenciacion
