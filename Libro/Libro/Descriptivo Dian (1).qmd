
# <font color="red">Análisis descriptivo del recaudo de impuestos internos por la DIAN</font>
``` {r}
#| warning: false
#| echo: false
library(TSstudio)
library(readxl)
library(dplyr)
library(lubridate)
library(astsa)
library(feasts)
library(fable)
library(timetk)
library(tsibble)
library(zoo)
library(xts)
library(readxl)
library(tidyverse)
library(forecast)
library(plotly)


#### Base de datos de la DIAN #####
setwd("C:/Users/andre/OneDrive/Escritorio/Andrés/2023-2/Series de tiempo/Proyecto")
dian<-read_excel("dian.xlsx", range="A7:C313", sheet = "Rec mensual a junio 2023" )
años<-2000:2023
dian<-dplyr::filter(dian,Año %in% años)
colnames(dian)<-c("Año","Mes","Impuestos")
dian$fecha<-as.Date(paste(dian$Año, dian$Mes, "1", sep = "-"), format = "%Y-%B-%d")
dian<-dian[,3:4]

## Serie de tiempo de la DIAN ##
dian2<-ts(dian$Impuestos,start=c(2000,01),frequency=12)

#### Base de datos de energia ####
AEP_hourly<-read.csv("AEP_hourly.csv")
AEP_hourly$Datetime<-as.POSIXct(AEP_hourly$Datetime, format = "%Y-%m-%d %H:%M:%S")
AEP_hourly$fecha<-as.Date(AEP_hourly$Datetime)

energia <- AEP_hourly %>%
  group_by(fecha) %>%
  summarise(Energia = sum(AEP_MW))
energia<-energia[-5055,]

## Serie de tiempo de la energia ##
energia2<-ts(energia$Energia,start=c(2004,10,01),frequency=365.25)
```
El gráfico de nuestra serie de tiempo viene dado por:
```{r}
plot(dian2, main="Serie de tiempo del recaudo mensual interno",
     cex.main=1.3,
     xlab="Tiempo",
     ylab="Recaudo interno",
     cex.lab=0.4)
```

Según lo observado en la serie de tiempo, preliminarmente se tiene que la serie presenta:

* **Heterocedasticidad marginal:** Se puede observar que la varianza de cada instante en la serie no es la misma, a medida que pasa el tiempo esta va aumentanto, por lo tanto surge la necesidad de realizar una transformación Box-cox.
* **Tendencia:** A simple vista se observa que, a medida que pasa el tiempo, la serie oscila al rededor de valores cada vez más grandes, por lo tanto, es necesario estimar la tendencia y posteriormente eliminarla para poder continuar con el análisis de la serie.
* **Componente estacional:** e observan algunos patrones que se repiten con cierta periodicidad (posiblemente cada año), lo cual hace que sea necesario estimar posibles comportamientos estacionales.

## <font color="red">Estabilización de la varianza marginal</font>


Teniendo en cuenta lo observado utilizando el gráfico de la serie de tiempo, se puede evidenciar una heterocedasticidad marginal la cual debemos corregir, para esto utilizaremos la transformación de Box-cox, esto teniendo en cuenta que no se tienen valors negativos, de este modo se tiene que 



``` {r}
MASS::boxcox(lm(dian2 ~ 1),seq(-5, 5, length = 50)) ##Notese que no acputra al 1
forecast::BoxCox.lambda(dian2, method ="loglik",
                        lower = -1, upper = 3)#Entrega el valor de lambda (0.1).
```
Con el anterior gráfico y salida podemos observar que el valor que maximiza la log-verosimilitud es 0.1, pero este valor es bastante cercano a 0, por lo tanto lo aproximaremos para asi poder utilizar la transformación logaritmo, notese que el intervalo de confianza no captura al 1 por lo tanto puede ser conveniente realizar la transformación. En los gráficos posteriores analizaremos si dicha transformación logra estabilizar la varianza marginal de nuestros datos.

``` {r}
plot(forecast::BoxCox(dian2,lambda=0.1))
par(mar = c(1,1,1,1))
ldian2=log(dian2)
MASS::boxcox(lm(ldian2 ~ 1),seq(-5, 5, length = 50)) #Si captura al 1

```
Notese que el intervalo de confianza de la transformación Box-cox logra capturar el valor de 1, lo cual nos indica que no es necesario transformar los datos nuevamente y que la transformación ayudo de buena manera a estabilizar la varianza marginal de nuestra serie de tiempo.

En el siguiente gráfico mostramos la serie de recaudo de la Dian con y sin la transformación logaritmo y es posible observar que la escala disminuye pero a su vez se observan algunos cambios considerables en la forma de la serie, lo cual es un buen indicativo de la relevancia de realizar la transformación.
``` {r}
#par(mfrow=c(2,1))
plot(dian2,main="Serie Dian sin Transformar")
plot(ldian2,main="Series Dian con Transformación BoxCox")
```
Teniendo lo anterior en cuenta, presentaremos un gráfico de la serie sin tendencia un poco más interactivo e informativo, con el fin  de lograr conocer los distintos valores en cada una de las fechas.
```{r}
class(ldian2)

dian3<-window(ldian2, start = c(2000,1))
ts_plot(dian3,title="Serie de tiempo del recaudo mensual interno",
        Ytitle="Recaudo interno",
        Xtitle="Tiempo",
        Xgrid=TRUE,
        Ygrid=TRUE)
```
## <font color="red">Tendencia Estimación y eliminación</font>
Luego de estabilizar la varianza marginal de nuestra serie, procederemos a estimar la tendencia y a eliminarla.
Para estimar dicha tendencia inicaremos utilizando una tendencia lineal deterministica y posteriormente restaremos dicha tendencia estimada a los datos de nuestra serie, de este modo se tiene lo siguiente:
```{r}
summary(fit<-lm(ldian2~time(ldian2),na.action=NULL))
plot(ldian2,ylab="Recaudo interno") 
abline(fit,col="darkcyan",lwd=2)
```
Preliminarmente es posible ver que la recta se ajusta de un buen modo a nuestra serie de tiempo, puesto que la tendencia de nuestra serie es creciente,  ahora procederemos a observar la serie de tiempo al eliminar la tendencia utilizando este metodo y tenemos lo siguiente:
```{r}
ElimiTenddian<-ldian2-predict(fit)
plot(ElimiTenddian,main="Serie Dian sin tendencia y con varianza estable",
     cex.main=1.3,
     xlab="Tiempo",
     ylab="Recaudo interno",
     cex.lab=0.4)
```
Es posible observar que nuestra serie de tiempo cambio considerablemente, puesto que la escala de los valores se disminujo bastante y además los datos oscilan al rededor del 0, lo cual nos indica que nuestra serie no presenta tendencia

```{r}
acf(ElimiTenddian,lag.max=179,main="Acf Serie Dian sin tendencia")
```
Notese que el gráfico de autocorrelación, nos indica preliminarmente la presencia de posibles componente estacionales, pero esto lo analizaremos un poco más en detalle más adelante.

Pero este no es el unico modo de realizar la estimación de la tendencia, tambien podemos utilizar herramientas no parametricas, pero como no hemos identificado la componente estacional, estas nos daran una estimación preliminar de la tendencia. La primera de ellas que vamos a utilizar es la descomposición via filtros de promedios moviles, que se presenta a continuación:
```{r}
dian_decompo=decompose(ldian2)
plot(dian_decompo)
#dian_decompo$trend
```
Notese que la tendencia estimada via filtros de promedio moviles es aproximadamente lineal, lo cual respalda la idea de utilizar la forma deterministica de estimar la varianza, además parece estimar de mdodo correcto la componente estacional y en la componente residual se observan algunos patrones estacionales.

Ahora procederemos a utilizar la descomposción STL, para hacer un análisis similar.
```{r}
library(feasts)
library(fable)
### Gráfico ##
tsibble_dian<-as_tsibble(ldian2)
str(tsibble_dian)
tsibble_dian %>%
  model(
    STL(value ~ trend() +
          season(window = "periodic"),
        robust = TRUE)) %>%
  components() %>%
  autoplot()
#tsibble_dian_notendstl<-tsibble_dian$Log
```
Notese que el gráfico anterior es bastante similar al obtenido utilizando filtro de promedios moviles y podemos realizar una interpretación bastante similar, Tambien es posible eliminar la tendencia utilizando diferenciación, pero se debe tener en cuenta que la diferenciación tambien puede eliminar la componente estacional que se tenga presente en la serie de tiempo, a continuación se muestra la manera en que se realizó la eliminación de la tendencia utilizando la diferenciación y su comparación con el primer metodo para eliminar tendencia utilizado.
```{r}
par(mar = c(2,2,2,2))
fitdian = lm(ldian2~time(ldian2), na.action=NULL) 
par(mfrow=c(2,1))
plot(resid(fitdian), type="l", main="sin tendencia") 
plot(diff(ldian2), type="l", main="Primera Diferencia") #Primera diferencia ordinaria
```
Notese que cuando eliminamos la tendencia utilizando la diferenciación se observa un poco más centrada en comparación a cuando utilizamos la regresión lineal ajustada, esto puede ser producto de la posible eliminación de la componente estacional producto de la utilización de la diferenciación **Revisar bien esta interpretacion con las muchachas**

En el siguiente grafico se compara las funciones de autocorrelación obtenidas para la series cuando eliminamos la tendencia utilizando lm y utilizando diferenciación, junto con la función de autocorrelación para la serie de tiempo con varianza marginal estable.
```{r}
par(mar = c(3,2,3,2))
par(mfrow=c(3,1)) # plot ACFs
acf(ldian2, 60, main="ACF Dian objeto ts varianza estable por boxcox")
acf(resid(fitdian), 60, main="ACF Sin tendencia (resid(fitdian))") 
acf(diff(ldian2), 60, main="ACF Primera Diferencia")
```
**Falta interpretación WAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA**

## <font color="red">Detección de estacionalidad</font>
Luego de estabilizar la varianza marginal y de tratar la tendencia, procedemos a observar si existe presencia de posibles ciclos o ciclos estacionales, para dicha tarea vamos a emplear multiples metodos descriptivos que nos permiten obtener información sobre esta componente.
Iniciaremos por observar el grafico de retardos, el cual viene dado a continuación:
```{r}
ts_info(ElimiTenddian)
par(mar = c(3,2,3,2))
astsa::lag1.plot(ElimiTenddian, 12,corr=F)
ts_lags(ElimiTenddian,lags=1:12)
```
El gráfico de retardos nos indica de manera descriptiva la posible relación existente entre un tiempo y algunos de sus retardos, para este caso en particular se toman 12 retardos (esto teniendo en cuenta la frecuencia mensual de la serie de tiempo), en este caso es posible observar que existe una clara relación lineal y directa con el rezago 12, los demás rezagos no parecen ser del todo significativos.
Notese que los dos graficos anteriores nos dan una información bastante similar.

Ahora observemos el gráfico de subseries, el cual toma los valores por cada mes de cada uno de los años dentro la serie, como sabemos buscamos obsevar si en el historico encontramos dieferentes valores medio mes tras mes, de este modo tenemos lo siguiente:
```{r}
require(feasts)
dian2_tsbl_notend=as_tsibble(ElimiTenddian)
dian2_tsbl_notend%>%gg_subseries(value)
```
Es posible observar que la media en cada uno de los meses es distinta, esto es un claro indicio de la presencia de una componente ciclica estacional o ciclica, a contibuación se presentan algunas otras graficas descriptivas para observar la presencia de un ciclo estaciona.
```{r}
dian2sint_df <- data.frame(year = floor(time(ElimiTenddian)), month = cycle(ElimiTenddian),ElimiTenddian = as.numeric(ElimiTenddian))
dian2sint_df$month <- factor(month.abb[dian2sint_df$month], levels = month.abb)
dian2sint_summary <- dian2sint_df %>%group_by(month) %>%summarise(mean= mean(ElimiTenddian),sd = sd(ElimiTenddian))
dian2sint_summary
plot_ly (data = dian2sint_summary, x = ~ month, y = ~ mean, type = "bar", name   = "Mean") %>%
  layout (title = "dian2sint - Monthly Average", yaxis =list(title = "Mean",   range = c(min(dian2sint_summary$mean), max(dian2sint_summary$mean))))
```
En el anterior gráfico se observa el valor medio tomado por cada uno de los meses, es posible observar que tiene un comportamiento parecido al grafico de subseries y de manera analoga nos muestra que exite una componente estacional.

A continuación se muestran los mapas de calor para la serie Dian con varianza maeginal estable y tendencia eliminada por el metodo de diferenciacion y lineal.
```{r}
TSstudio::ts_heatmap(ElimiTenddian,title = "Mapa de Calor - Impuestos Dian sin tendencia")
TSstudio::ts_heatmap(diff(ldian2),title = "Mapa de Calor - Impuestos Dian sin tendencia")
```
Ambos mapas nos dan una información similar, en los cuales es posible observar que en los meses de noviembre, enero, junio, mayo y abril se tienen una mayor cantidad de recaudo de impuestos, mientras que en diciembre,octubre, agosto, marzo y febrero tienen un menor valor de recaudo de impuestos año tras año, nuevamente este gráfico nos ayuda a comprender la existencia de un cliclo estacional que posiblemente tenga un periodo de 12 meses.

### <font color="red">Periodograma</font>
Cuando hablamos de una componente estacional dentro de nuestra serie de tiempo, tambien necesitamos hablar de su periodo y de su frecuencia, para esto utilizaremos el periodograma.
```{r}
spectrum(as.numeric(ElimiTenddian),log='no')
abline(v=0.5, lty=2,col="red")
spectrum(as.numeric(ElimiTenddian),log='no',span=5)
spectrum(as.numeric(ElimiTenddian),log='no',span=c(5,5))
spectrum(as.numeric(ElimiTenddian),log='no',span=c(2,2))
```
Notese que en los graficos anteriores se tienen diferentes valores de suavizamiento para nuestro periodograma, pues aunque en este caso no es dificil observar los puntos donde se tiene un pico, el suavizamiento puede ayudarnos a observar de mdood más simple los picos que son verdaderamente 
significativos.
```{r}
Periodgramadldian2_sintendencia=spectrum(as.numeric(ElimiTenddian),log='no')
ubicacionlogdian=which.max(Periodgramadldian2_sintendencia$spec)
sprintf("El valor de la frecuencia donde se máximiza el periodograma para la serie es: %s",Periodgramadldian2_sintendencia$freq[ubicacionlogdian])

sprintf("El periodo correspondiente es aproximadamente: %s",1/Periodgramadldian2_sintendencia$freq[ubicacionlogdian])
```
Notese que según la salida obtenida, la frecuencia maxima se alcanza en 0.5 (es decir en 6/12=0.5) y se obtuvo que el periodo es 2, esto quiere decir que el ciclo se repite cada dos meses, pero notese que este es un multiplo no entero de 12, por lotanto en realidad se tiene que el periodo de la componente estacional serie de tipo anual (12 meses) **Mirar esta interpretación con las muchachas y preguntar al profe si esta correcto**.

## <font color="red">Desestacionalizar o eliminación de la componente estacional</font>




